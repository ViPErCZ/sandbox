<?php

namespace Model\Permission;

use Model\Permission\Entity\UserEntity;
use Nette\Utils\DateTime;
use Nette\Utils\Paginator;
use Sandbox\PasswordRecovery\IUserModel;
use slimORM\AbstractRepository;
use slimORM\Entity\Entity;
use slimORM\EntityManager;
use Tracy\Debugger;

/**
 * Description of UserRepository
 *
 * @author Martin Chudoba
 */
class UserRepository extends AbstractRepository implements IUserModel {

	/** constant */
	const ENTITY = '\Model\Permission\Entity\UserEntity';

	/**
	 * @param EntityManager $entityManager
	 */
	public function __construct(EntityManager $entityManager) {
		parent::__construct($entityManager, UserRepository::ENTITY);
	}

	/**
	 * @param string $key
	 * @return UserEntity|NULL
	 */
	public function get($key) {
		return parent::get($key);
	}

	/**
	 * @param Paginator $paginator
	 * @return UserRepository
	 */
	public function read(Paginator $paginator = NULL) {
		return parent::read($paginator)->select("*, role.name AS roleName");
	}

	/**
	 * @return TRUE
	 */
	public function save() {
		return parent::save();
	}

	/**
	 * @param Entity $entity
	 * @return UserRepository
	 */
	public function push(Entity $entity) {
		return parent::push($entity);
	}

	/**
	 * @return UserEntity|NULL
	 */
	public function fetch() {
		return $this->entityManager->getRepository(UserRepository::ENTITY)->fetch();
	}

	/**
	 * @param $condition
	 * @param array $parameters
	 * @return $this
	 */
	public function where($condition, $parameters = array()) {
		return parent::where($condition, $parameters); // TODO: Change the autogenerated stub
	}

	/**
	 * @param $userID
	 * @return bool|string
	 * @throws \slimORM\Exceptions\RepositoryException
	 */
	public function deactivate($userID) {
		try {
			$repository = $this->entityManager->getRepository(UserRepository::ENTITY);
			/** @var UserEntity $user */
			foreach ($repository->read()->where("userID", $userID) as $user) {
				if ($user->getUserID() != 1) {
					$user->setActive(false);
				}
			}
			$repository->save();
			return TRUE;
		} catch (\PDOException $e) {
			return $e->getMessage();
		}
	}

	/**
	 * @param $email
	 * @return bool
	 */
	public function isUserValid($email) {
		return $this->read()->where("login", $email)->count('*') == 1;
	}

	/**
	 * @param string $token
	 * @param int $expirationTime
	 * @return bool
	 */
	public function isTokenValid($token, $expirationTime = 10) {
		try {
			$user = $this->read()->where("recoveryToken", $token)->limit(1)->fetch();
			if ($user) {
				$current = new DateTime();
				$diff = $current->diff(new DateTime($user->getRecoveryTokenInserted()));
				if ($diff->format("%h") == 0 && $diff->format("%i") <= $expirationTime) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} catch (\PDOException $e) {
			return false;
		}
	}

	/**
	 * @param $token
	 * @param $newPassword
	 * @return string|TRUE
	 */
	public function resetPassword($token, $newPassword) {
		try {
			$user = $this->read()->where("recoveryToken", $token)->limit(1)->fetch();
			if ($user) {
				$user->setPassword($newPassword);
				$user->setRecoveryToken(null);
				$user->setRecoveryTokenInserted(null);
				return $this->save();
			}
		} catch (\PDOException $e) {
			return $e->getMessage();
		}
	}

	/**
	 * @param $email
	 * @param $token
	 * @return string|TRUE
	 */
	public function saveToken($email, $token) {
		try {
			$user = $this->read()->where("login", $email)->limit(1)->fetch();
			if ($user) {
				$user->setRecoveryToken($token);
				$user->setRecoveryTokenInserted(new DateTime());
				return $this->push($user)->save();
			}
		} catch (\PDOException $e) {
			return $e->getMessage();
		}
	}
}
